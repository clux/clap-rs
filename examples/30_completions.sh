# foo(1) completion
# autogenerated by clap

_foo()
{
    local cur prev words cword
    _init_completion || return

    local -r binname="foo"
    local -r subcommands="bar baz qux"
    local -r subcommands_pattern=@(bar|baz|qux)
    local -r global_flags="-v"

    # Check if global subcommands are used
    local has_sub
    local subcmd
    for (( i=0; i < ${#words[@]}-1; i++ )); do
        if [[ ${words[i]} == $subcommands_pattern ]]; then
            has_sub=1
            subcmd=${words[i]}
        fi
    done
    # Suggest global flags if no subcommands, and argument starts with a dash
    if [[ -z "$has_sub" && "$cur" == -* ]]; then
        COMPREPLY=( $(compgen -W "$global_flags" -- "$cur" ) )
        return 0
    fi

    # Suggest global subcommands if there are no subcommands already set
    if [[ -z "$has_sub" ]]; then
        COMPREPLY=( $(compgen -W "$subcommands" -- "$cur" ) )
        return 0
    fi

    # Subcommand flag + option, then special completions
    # subcommand::baz
    # NB: normal completion example without specifying anything to clap
    #if [[ $subcmd = "baz" && "$cur" == -* ]]; then
    #    local -r baz_flags="-h --help"
    #    COMPREPLY=( $(compgen -W "$baz_flags" -- "$cur" ) )
    #    return 0
    #fi

    # subcommand::bar
    # NB: advanced example with argument completion on bar
    #if [[ $subcmd = "bar" && "$cur" == -* ]]; then
    #    local -r bar_flags="-h --help"
    #    COMPREPLY=( $(compgen -W "$bar_flags" -- "$cur" ) )
    #    return 0
    #fi
    #if [[ $subcmd = "bar" ]]; then
    #    local -r bar_args=$($binname __bar_suggestions)
    #    COMPREPLY=( $(compgen -W "$bar_args" -- "$cur" ) )
    #    return 0
    #fi

    # subcommand::qux
    # NB: advanced example with subcommands on a subcommand
    #if [[ $subcmd = "qux" && "$cur" == -* ]]; then
    #    local -r qux_flags="-h --help"
    #    COMPREPLY=( $(compgen -W "$qux_flags" -- "$cur" ) )
    #    return 0
    #fi
    #local -r qux_subcommands="corge grault"
    #local -r qux_subcommands_pattern=@(corge|grault)
    ## Check if subcommands of qux are used
    #if [[ $subcmd = "qux" ]]; then
    #    local qux_has_sub
    #    local qux_subcmd
    #    # TODO: start from index of previous subcmd?
    #    for (( i=0; i < ${#words[@]}-1; i++ )); do
    #        if [[ ${words[i]} == $qux_subcommands_pattern ]]; then
    #            qux_has_sub=1
    #            qux_subcmd=${words[i]}
    #        fi
    #    done
    #    # Suggest qux subcommands if there are no subcommands already
    #    if [[ -z "$qux_has_sub" ]]; then
    #        COMPREPLY=( $(compgen -W "$qux_subcommands" -- "$cur" ) )
    #        return 0
    #    fi
    #    # subcommand::qux::corge
    #    if [[ $qux_subcmd = "corge" && "$cur" == -* ]]; then
    #        local -r qux_corge_flags="-h --help"
    #        COMPREPLY=( $(compgen -W "$qux_corge_flags" -- "$cur" ) )
    #        return 0
    #    fi
    #    # subcommand::qux::grault
    #    if [[ $qux_subcmd = "grault" && "$cur" == -* ]]; then
    #        local -r qux_grault_flags="-h --help"
    #        COMPREPLY=( $(compgen -W "$qux_grault_flags" -- "$cur" ) )
    #        return 0
    #    fi
    #    # stopping the example madness here - could just keep going at this point
    #fi

    return 0
} &&
complete -F _foo foo


